<!-- Markdownで数式を表示するためのスクリプト -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>

# マージ挿入ソート

### 概要
- マージ挿入ソート(別称: Ford–Johnson algorithm，以下MIソート)は，Lester FordとSelmer Johnsonによって1959年に開発されたソートアルゴリズムである．
- MIソートは，**ソート時の比較回数を最小限に抑える**ことに焦点を当てている(ソートの速度を上げることではない)．
- MIソートは，二分挿入ソート[^1]を組み込んだマージソート[^2]だと解釈できる．
- MIソートは，二分挿入ソートにおける要素の挿入順序を最適化することで，ソート時の比較回数を最小限に抑えることができる(最適化手法は[備考](#備考)を参照のこと)．
- Donald E. Knuthは，MIソートの二分挿入ソートにおける要素の挿入順序はJacobsthal数と対応することを発見した．
  そこで，MIソートの二分挿入ソートでは，要素の挿入順序をJacobsthal数によって決める

### 用語解説
  <dt>数列`large`</dt>
  <dd>
    数列`large`とは，入力数列を再起的に分割した2組のペアのうち，大きい方の要素数列である．
    なお，数列`large`は再起的にソートされ，また数列`small`から挿入されることから，主鎖(`main chain`)とも呼ばれる．
  </dd>
  <dt>数列`small`</dt>
  <dd>
    数列`small`とは，入力数列を再起的に分割した2組のペアのうち，小さい方の要素数列である．
    なお，数列`small`は再起的にソートされた数列`large`に挿入することから，保留(`pend`)とも呼ばれる．
  </dd>
  <dt>`smallAndLargePairs`</dt>
  <dd>
    `smallAndLargePairs`は，`large`の各要素と`small`の各要素の1対1のペアである．
    なお，`smallAndLargePairs`は主鎖(`main chain`)と保留(`pend`)との関係性を示すものであるからタグ(`tags`)とも呼ばれる．
  </dd>
  <dt>`remain`</dt>
  <dd>`remain`とは，入力数列が奇数の時に格納する入力数列の末尾の要素である．</dd>

### フロー
1. マージソートを行う
  1. 入力数列の要素数が奇数ならば，末尾の要素を`remain`に挿入することで，入力数列の要素数を偶数にする．
  1. 入力数列(初回は`seq`，2回目以降は`large`)に対して，隣同士で昇順のペアを作る
  1. ペアのうち，大きい方の要素を数列`large`に格納する
  1. `large`を入力数列として，要素数が1となるまで上記処理を再起的に実行する(これによって`large`がソートされる．言い換えれば，`seq`が大きい方の値でソートされる)
  1. `small`をソート済みの`large`の順序で並び替える
  1. `remain`が存在するならば，これを`small`の末尾に挿入する
  1. `small`の各要素を`large`に二分挿入ソートによって挿入する(これによって`small`と`large`に分割されていた入力数列が統合される)
    1. 挿入する`small`の要素の順序をJacobsthal数で決める
    1. 挿入する`small`の要素の位置を二分探索する
    1. `small`の要素を`large`に挿入する



### 備考
##### マージ挿入ソートにおける二分挿入ソートの最適化手法
##### 二分探索の性質
二分探索には次の性質があることが知られている．それは，ソート済み数列からのある要素を二分探索によって見つけるのに必要な比較の最大数は，要素数が $ 2^n $ のときと $ 2^{n+1} - 1 $ のときで同じであることだ．たとえば，8個の要素の中からある要素を見つけるのに必要な比較の最大数は，なんと15個の要素の中からある要素を見つけるのに必要な比較の最大数と等しい．

##### マージ挿入ソートにおける二分挿入ソートの最適化手法
MIソートは，ソート時の比較回数を最小限に抑えるために，二分探索の性質を活用している．具体的には，ソート済みの数列`large` $ \{ l_1, l_2, l_3, .. \} $ に`small`の各要素 $ \{ s_1, s_2, s_3, .. \} $ を挿入するときに，挿入位置を二分探索する範囲をできるだけ $ 2^{n+1} - 1 $ に抑えることを試みている．以下，例を用いて説明する．
1. `small`の挿入順序1番目の要素 $ s_1 $ をソート済み数列`large` $ \{ l_1, .. \} $ に挿入する．ここで $ l_1 > s_1 $ より，1つ目の要素を挿入するときは，ソート済み数列`large`の先頭に挿入すれば良い．したがって， $ \{ s_1, l_1, l_2, l_3, .. \} $ となる．
2. `small`の挿入順序2番目の要素 $ s_3 $ をソート済み数列`large` $ \{ s_1, l_1, l_2, l_3, .. \} $ に挿入する．ここで， $ l_3 > s_3 $ を踏まえると，挿入順序2番目の要素 $ s_3 $ の挿入位置を二分探索する範囲は3( $ s_1 $ か $ l_1 $ のとなり)だとわかる．
3. `small`の挿入順序3番目の要素 $ s_2 $ を $ s_3 $ の挿入位置とは無関係にソート済み数列`large` $ \{ s_1, l_1, l_2, .. \} $ に挿入する．ここで， $ l_2 > s_2 $ を踏まえると，挿入順序2番目の要素 $ s_2 $ の挿入位置を二分探索する範囲は3( $ s_2 $ か $ l_2 $ のとなり)だとわかる．
4. `small`の挿入順序k番目の要素 $ s_k $ をソート済み数列`large`に挿入する．比較回数を最小化する要素の挿入順序は，Jacobsthal数[^3]と対応している．最初に3番目の要素を挿入し，以降は5，11，21番目..の要素を挿入する．



#### 注・引用・参考文献一覧
- programgenjin(2019). "C++でマージソートを実装してみる", プログラミング原人の進化論. <https://programgenjin.hatenablog.com/entry/2019/02/22/210806>. 2024年11月1日閲覧
- KDonald E. Knut(2015). "The Art of Computer Programming Volume 3 Sorting and Searching Second Edition 日本語版". 達人出版会
- PunkChameleon(2020). "ford-johnson-merge-insertion-sort: An implementation of the Ford-Johnson Merge-Insertion Sort Algorithm in Python", GitHub. <https://github.com/PunkChameleon/ford-johnson-merge-insertion-sort>. 2024年11月1日閲覧
- jizots(2024). "【C++】Merge-insertion sort. Ford-Johnson algorithm ##merge_insertion_sort", Qiita. <https://qiita.com/jizots/items/0d484a173c1921d2083e>. 2024年11月1日閲覧
- Pro_ktmr(2020). "図解】二分探索はもう間違えない！スリーステップ実装法＆記憶に残るアニメーション #C++", Qiita. <https://qiita.com/Pro_ktmr/items/8946723fe08ba29a977c>. 2024年11月6日閲覧

---

[^1]: 二分挿入ソート(別称: バイナリインサートソート)とは，挿入ソートの一種である．挿入ソートとは，ソート済みの数列に，新たな要素を適当な位置に挿入するソートアルゴリズムである．二分挿入ソートとは，ソート時の比較回数(挿入位置の探索回数)を抑えることを目的として，挿入位置を二分探索によって求める挿入ソートアルゴリズムである．これは，挿入される数列がソート済みであるという性質を利用している．

[^2]: > マージソートは分割統治法を利用した高速なソートアルゴリズムです。分割統治法とは、問題を分割（devide）して部分問題を解いて（solve）から、それらを統合（conquer）して解を得る手法の総称です。
マージソートでは、配列をどんどん２つに分割していき、１要素ごとにまで分解してから、ソートしながら統合します。
programgenjin(2019). "C++でマージソートを実装してみる", プログラミング原人の進化論. <https://programgenjin.hatenablog.com/entry/2019/02/22/210806>. 2024年11月1日閲覧

[^3]: Jacobsthal数列とは次の漸化式である．
$$ J_0 = 0, J_1 = 1, J_n = J_{n-1} + J_{n-2} (n ≥ 2) $$
Jacobsthal数列の最初の数値は以下の通りである: 0, 1, 1, 3, 5, 11, 21, ...
